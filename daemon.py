"""
Generated by Google Gemini 2.5-Pro.
"""

import time
import logging

# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)


# Config vars for testing
DEFAULT_BAO_ADDR = "http://127.0.0.1:8200"
DEFAULT_BAO_VAULT_TOKEN = "dev-only-token"
DEFAULT_OPENBAO_SECRETS_PATH = "test"
DEFAULT_MONGO_DATA_LAKE_NAME = "babylonDataLake"
DEFAULT_EMBEDDINGS_COLLECTION_CHROMA = "babylon_vectors"
# 5 minutes
DEFAULT_MIN_LOOP_SECONDS = 300

class Daemon:
    """
    A simple daemon class that runs a processor in a loop.

    It ensures that each loop iteration (including processing time)
    takes at least 'min_loop_seconds'.
    """

    # def __init__(self, processor, min_loop_seconds):
    def __init__(self, **config: dict):
        self._processor = ExampleDataProcessor()
        self._min_loop_seconds: int = config['MIN_LOOP_SECONDS']
        self._running = True  # Flag to control the loop

    def run(self):
        """
        Starts the daemon's main processing loop.
        """
        log.info(f"Daemon starting. Minimum loop time: {self._min_loop_seconds}s")
        while self._running:
            # Record the start time of the loop
            start_time = time.time()

            try:
                # --- Invoke the processor ---
                log.debug("Invoking processor...")
                self._processor.process()
                log.debug("Processor finished.")
                # -----------------------------

            except Exception as e:
                # Catch exceptions from the processor so the daemon doesn't crash
                log.error(f"Error in processor: {e}", exc_info=True)

            # Calculate how long the processing took
            end_time = time.time()
            duration = end_time - start_time

            # Calculate how long we need to sleep to meet the minimum loop time
            sleep_time = self._min_loop_seconds - duration

            if sleep_time > 0:
                # If the processor finished faster than the min loop time, sleep
                log.debug(f"Process took {duration:.2f}s. Sleeping for {sleep_time:.2f}s.")
                time.sleep(sleep_time)
            else:
                # The processor took longer than the minimum loop time.
                # Don't sleep, just log it and continue to the next loop.
                log.warning(f"Loop overrun: Process took {duration:.2f}s, which is > {self.min_loop_seconds}s.")

        log.info("Daemon shutting down.")

    def stop(self):
        """
        Signals the daemon to stop its loop.
        """
        log.info("Stop signal received.")
        self._running = False


class ExampleDataProcessor:
    """
    An example processor class. The Daemon only requires
    an object with a 'process' method.
    """

    def __init__(self):
        self.counter = 0

    def process(self):
        """
        The main work method called by the daemon.
        """
        self.counter += 1
        log.info(f"--- Processing data: Batch {self.counter} ---")

        # Simulate some work that takes 1 second
        time.sleep(1)

        log.info(f"--- Finished processing: Batch {self.counter} ---")


# --- Example Usage ---
if __name__ == "__main__":
    print("Mock environment loaded")
    config = {
        "DEFAULT_BAO_ADDR": DEFAULT_BAO_ADDR,
        "DEFAULT_BAO_VAULT_TOKEN": DEFAULT_BAO_VAULT_TOKEN,
        "DEFAULT_OPENBAO_SECRETS_PATH": DEFAULT_OPENBAO_SECRETS_PATH,
        "DEFAULT_MONGO_DATA_LAKE_NAME": DEFAULT_MONGO_DATA_LAKE_NAME,
        "DEFAULT_EMBEDDINGS_COLLECTION_CHROMA": DEFAULT_EMBEDDINGS_COLLECTION_CHROMA,
        "MIN_LOOP_SECONDS": DEFAULT_MIN_LOOP_SECONDS

    }

    # 1. Create the processor
    my_processor = ExampleDataProcessor()

    # 2. Create the daemon, injecting the processor and setting a 5-second loop
    my_daemon = Daemon(**config)

    # 3. Run the daemon
    # This will block the main thread until you press Ctrl+C
    try:
        my_daemon.run()
    except KeyboardInterrupt:
        log.info("Caught KeyboardInterrupt, stopping daemon...")
        my_daemon.stop()
        # The loop will finish its current iteration and then exit
